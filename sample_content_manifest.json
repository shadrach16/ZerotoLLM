{
  "version": 1,
  "courses": [
    {
      "id": "course_micrograd",
      "title": "Micrograd: Backprop from Scratch",
      "thumbnail": "assets/micrograd-thumbnail.jpg",
      "sequence_order": 1,
      "chapters": [
        {
          "id": "micrograd_ch1",
          "title": "The Value Object",
          "video_id": "VMj-3S1tku0",
          "description":"Description 1",
          "start": 0,
          "end": 80,
          "xp_reward": 50,
          "tasks": [{
            "type": "gap_fill",
            "instruction": "Complete the Value class constructor. The Value object wraps a scalar and tracks gradients.",
            "template": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = ___\n        self.grad = 0\n        self._backward = lambda: None\n        self._prev = set(_children)\n        self._op = _op",
            "solution": "data",
            "hints": [
              "The data parameter should be stored in the data attribute"
            ]
          }]
        },
        {
          "id": "micrograd_ch2",
          "title": "Addition Operation",
          "video_id": "VMj-3S1tku0",
          "start": 480,
          "end": 960,
          "xp_reward": 75,
          "tasks": [{
            "type": "gap_fill",
            "instruction": "Implement the __add__ method for the Value class.",
            "template": "def __add__(self, other):\n    other = other if isinstance(other, Value) else Value(other)\n    out = Value(self.data + other.data, (self, other), '+')\n    \n    def _backward():\n        self.grad += out.grad\n        other.grad += ___\n    out._backward = _backward\n    \n    return out",
            "solution": "out",
            "hints": [
              "The gradient of addition distributes equally to both operands"
            ]
          }]
        },
        {
          "id": "micrograd_ch3",
          "title": "Multiplication & Chain Rule",
          "video_id": "VMj-3S1tku0",
          "start": 960,
          "end": 1440,
          "xp_reward": 100,
          "tasks": [
            {
              "type": "quiz",
              "instruction": "What is the primary purpose of the Value object?",
              "solution": "To store data and gradients",
              "options": ["To store data and gradients", "To plot graphs", "To fetch data from internet"]
            },
            {
              "type": "gap_fill",
              "instruction": "Complete the constructor.",
              "template": "class Value:\n    def __init__(self, data):\n        self.data = ___\n        self.grad = 0",
              "solution": "data"
            },
            {
  "type": "parsons",
  "instruction": "Arrange the lines to calculate the gradient.",
  "solution": "x.grad += 1.0\nx._backward()",
  "lines": ["x._backward()", "x.grad += 1.0", "x.data += 1.0", "return x"],
  "hints": ["You must set the seed gradient before backpropagating."]
}
          ]
        }
      ]
    },
    {
      "id": "course_micrograd_2",
      "title": "Micrograd: Backprop from Scratch Part 2",
      "thumbnail": "assets/tensor-core-icon.png",
      "sequence_order": 2,
      "chapters": [
        {
          "id": "micrograd_ch1_2",
          "title": "The Value Object",
          "video_id": "VMj-3S1tku0",
          "start": 0,
          "end": 480,
          "xp_reward": 50,
          "tasks": [{
            "type": "gap_fill",
            "instruction": "Complete the Value class constructor. The Value object wraps a scalar and tracks gradients.",
            "template": "class Value:\n    def __init__(self, data, _children=(), _op=''):\n        self.data = ___\n        self.grad = 0\n        self._backward = lambda: None\n        self._prev = set(_children)\n        self._op = _op",
            "solution": "data",
            "hints": [
              "The data parameter should be stored in the data attribute"
            ]
          }]
        },
        {
          "id": "micrograd_ch2_2",
          "title": "Addition Operation",
          "video_id": "VMj-3S1tku0",
          "start": 480,
          "end": 960,
          "xp_reward": 75,
          "tasks": [{
            "type": "gap_fill",
            "instruction": "Implement the __add__ method for the Value class.",
            "template": "def __add__(self, other):\n    other = other if isinstance(other, Value) else Value(other)\n    out = Value(self.data + other.data, (self, other), '+')\n    \n    def _backward():\n        self.grad += ___\n        other.grad += ___\n    out._backward = _backward\n    \n    return out",
            "solution": "out.grad\nout.grad",
            "hints": [
              "The gradient of addition distributes equally to both operands"
            ]
          }]
        },
        {
          "id": "micrograd_ch3_2",
          "title": "Multiplication & Chain Rule",
          "video_id": "VMj-3S1tku0",
          "start": 960,
          "end": 1440,
          "xp_reward": 100,
          "tasks": [{
            "type": "code",
            "instruction": "Implement the backward pass for multiplication using the chain rule.",
            "template": "def __mul__(self, other):\n    other = other if isinstance(other, Value) else Value(other)\n    out = Value(self.data * other.data, (self, other), '*')\n    \n    def _backward():\n        # TODO: Implement backward pass\n        pass\n    out._backward = _backward\n    \n    return out",
            "solution": "def __mul__(self, other):\n    other = other if isinstance(other, Value) else Value(other)\n    out = Value(self.data * other.data, (self, other), '*')\n    \n    def _backward():\n        self.grad += other.data * out.grad\n        other.grad += self.data * out.grad\n    out._backward = _backward\n    \n    return out",
            "hints": [
              "Use the product rule: d/dx(uv) = u'v + uv'"
            ]
          }]
        }
      ]
    }
  ]
}
